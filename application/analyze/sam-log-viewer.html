<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SAM Log Analyzer</title>
    <style>
        body {
            font-family: system-ui, sans-serif;
            margin: 20px;
            line-height: 1.5;
        }

        h1,
        h2,
        h3 {
            color: #2a4d69;
        }

        textarea {
            width: 100%;
            height: 200px;
            margin: 10px 0;
            padding: 8px;
            font-family: monospace;
        }

        .result {
            border: 1px solid #ccc;
            padding: 15px;
            margin-top: 20px;
            border-radius: 4px;
        }

        .debug-section {
            margin-top: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-left: 4px solid #dc3545;
        }

        .summary-log {
            margin: 5px 0;
            padding: 8px;
            background-color: #f8f9fa;
            border-left: 4px solid #2a4d69;
            cursor: pointer;
        }

        .summary-log:hover {
            background-color: #e9ecef;
        }

        .log-section {
            margin-bottom: 30px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 20px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 15px;
        }

        th,
        td {
            text-align: left;
            padding: 8px;
            border-bottom: 1px solid #ddd;
        }

        th {
            background-color: #f2f2f2;
        }

        .custom-data {
            font-family: monospace;
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .custom-data:hover {
            white-space: normal;
            overflow: visible;
        }

        pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            overflow: auto;
            font-family: monospace;
        }

        .status-rx {
            background-color: #d4edda;
        }

        .status-tx {
            background-color: #d1ecf1;
        }

        .status-error {
            background-color: #f8d7da;
        }

        .status-sync {
            background-color: #cce5ff;
        }

        .button {
            padding: 8px 12px;
            background-color: #2a4d69;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }

        .byte-marker {
            font-weight: bold;
            color: #dc3545;
        }
    </style>
</head>

<body>
    <h1>SAM Log Analyzer</h1>
    <p>Paste your SAM log output below to analyze the encoded data:</p>

    <textarea id="input" placeholder="Paste SAM log here..."></textarea>
    <button class="button" id="parse-button">Parse Logs</button>
    <button class="button" id="toggle-debug">Toggle Debug Info</button>

    <div class="result">
        <div id="debug-info" class="debug-section" style="display:none;"></div>
        <div id="summary-section"></div>
        <div id="detailed-results"></div>
    </div>

    <script>
        let debugMode = false;
        const debugInfo = [];

        // Z85 character set
        const Z85_CHARS = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-:+=^!/*?&<>()[]{}@%$#";

        // Check if a string contains only valid Z85 characters
        function isValidZ85String(str) {
            for (let i = 0; i < str.length; i++) {
                if (Z85_CHARS.indexOf(str[i]) === -1) {
                    return false;
                }
            }
            return true;
        }

        // Z85 decoder with strict validation
        function decodeZ85(encoded) {
            if (!encoded || encoded.length === 0) {
                addDebugMessage("Empty Z85 input");
                return new Uint8Array(0);
            }

            addDebugMessage(`Z85 input: ${encoded}`);

            // Validate the entire string contains only Z85 characters
            if (!isValidZ85String(encoded)) {
                addDebugMessage("Z85 input contains invalid characters");
                return new Uint8Array(0);
            }

            const base85 = Z85_CHARS;
            const lookup = {};
            for (let i = 0; i < base85.length; i++) lookup[base85[i]] = i;

            // Get padding information from first character
            const paddingDigit = parseInt(encoded.charAt(0));
            let encodedData = encoded;
            let padding = 0;

            if (!isNaN(paddingDigit) && paddingDigit >= 1 && paddingDigit <= 4) {
                encodedData = encoded.substring(1);
                padding = 4 - paddingDigit;
                addDebugMessage(`Padding digit: ${paddingDigit}, padding: ${padding}`);
            } else {
                addDebugMessage("No valid padding digit found");
            }

            // Ensure encoded data is a multiple of 5
            if (encodedData.length % 5 !== 0) {
                const extra = encodedData.length % 5;
                encodedData = encodedData.substring(0, encodedData.length - extra);
                addDebugMessage(`Truncated ${extra} chars to make multiple of 5`);
            }

            if (encodedData.length === 0) {
                addDebugMessage("No valid encoded data after adjustments");
                return new Uint8Array(0);
            }

            // Calculate decoded length
            const decodedLength = Math.floor(encodedData.length * 4 / 5);
            addDebugMessage(`Calculated decoded length: ${decodedLength} bytes`);

            const result = new Uint8Array(decodedLength);

            // Perform decoding
            let j = 0;
            for (let i = 0; i < encodedData.length; i += 5) {
                if (i + 4 >= encodedData.length) break;

                let value = 0;
                for (let k = 0; k < 5; k++) {
                    value = value * 85 + lookup[encodedData[i + k]];
                }

                if (j + 3 < result.length) {
                    result[j] = (value >> 24) & 0xFF;
                    result[j + 1] = (value >> 16) & 0xFF;
                    result[j + 2] = (value >> 8) & 0xFF;
                    result[j + 3] = value & 0xFF;
                    j += 4;
                }
            }

            // Apply padding if needed
            if (!isNaN(paddingDigit) && paddingDigit < 4) {
                const finalResult = result.slice(0, decodedLength - padding);
                addDebugMessage(`Applied padding: final decoded length = ${finalResult.length}`);
                return finalResult;
            }

            return result;
        }

        // Create hex dump of binary data
        function hexDump(data) {
            const hexChars = '0123456789ABCDEF';
            let output = '';

            for (let i = 0; i < data.length; i++) {
                if (i % 16 === 0) {
                    if (i > 0) {
                        output += ' | ' + [...data.subarray(i - 16, i)].map(b => (b >= 32 && b <= 126) ?
                            String.fromCharCode(b) : '.').join('') + '\n';
                    }
                    output += (i).toString(16).padStart(4, '0') + ': ';
                }

                const byte = data[i];
                output += hexChars[(byte >> 4) & 0xF] + hexChars[byte & 0xF] + ' ';
            }

            // Add the last line if there's anything left
            if (output.endsWith(' ')) {
                const lastLineStart = Math.floor(data.length / 16) * 16;
                const padding = ' '.repeat(3 * (16 - (data.length % 16)));

                if (data.length % 16 !== 0) {
                    output += padding;
                }

                output += ' | ' + [...data.subarray(lastLineStart)].map(b =>
                    (b >= 32 && b <= 126) ? String.fromCharCode(b) : '.').join('');
            }

            return output;
        }

        // SAM Log parsing constants
        const SAM_LOG_HDR = {
            SLOT_IDX: (1 << 0),
            SLOTS_TO_USE: (1 << 1),
            SLOT_IDX_DIFF: (1 << 2),
            SCAN: (1 << 3),
            CUSTOM_FIELDS: (1 << 4),
            DEFAULT_SLOTS_TO_USE: (1 << 5)
        };

        const STATUS_NAMES = {
            0: 'RX_SUCCESS', 1: 'RX_TIMEOUT', 2: 'RX_ERROR', 3: 'RX_MALFORMED',
            4: 'RX_LISTEN_LATE', 5: 'RX_LISTEN_FAIL', 6: 'TIMER_EVENT', 7: 'TX_DONE',
            8: 'TX_SCHED_LATE', 9: 'TX_SCHED_FAIL', 14: 'SYNCH_DONE',
            15: 'SYNCH_FAIL', 16: 'SKIP_SUCCESS', 17: 'RESTART_LATE', 18: 'RESTART_FAIL',
            30: 'UNKNOWN'
        };

        // Get the CSS class for a status value
        function getStatusClass(status) {
            if (status === 0 || status === 1 || status === 4) return 'status-rx';
            if (status === 7) return 'status-tx';
            if (status === 14) return 'status-sync';
            if (status === 2 || status === 3 || status === 15) return 'status-error';
            return '';
        }

        // Validate action header
        function isValidActionHeader(buffer, pos) {
            if (pos >= buffer.length) {
                addDebugMessage(`Position ${pos} is beyond buffer length ${buffer.length}`);
                return false;
            }

            // First byte: check m_hdr and status
            const firstByte = buffer[pos];
            const m_hdr = (firstByte & 0x80) >> 7;
            const status = firstByte & 0x1F;

            // Status must be in valid range
            if (status > 30) {
                addDebugMessage(`Invalid status: ${status} > 30`);
                return false;
            }

            // Reserved bits must be 0
            if ((firstByte & 0x60) !== 0) {
                addDebugMessage(`Reserved bits not 0: ${(firstByte & 0x60).toString(2)}`);
                return false;
            }

            // If m_hdr is set, we need enough bytes for header
            if (m_hdr === 1) {
                if (pos + 1 >= buffer.length) {
                    addDebugMessage(`Not enough bytes for header`);
                    return false;
                }

                // Check header byte - must be a reasonable value
                const hdr = buffer[pos + 1];
                if (hdr > 63) {
                    addDebugMessage(`Invalid header byte: ${hdr} > 63`);
                    return false;
                }
            }

            return true;
        }

        // Get the total length of an action
        function getActionTotalLength(buffer, pos) {
            const firstByte = buffer[pos];
            const m_hdr = (firstByte & 0x80) >> 7;
            const status = firstByte & 0x1F;

            // If no m_hdr, just the status byte
            if (m_hdr === 0) {
                addDebugMessage(`Action at ${pos}: No extended header, size = 1`);
                return 1;
            }

            // Header byte is at position pos+1
            if (pos + 1 >= buffer.length) {
                addDebugMessage(`Action at ${pos}: Buffer too short for header`);
                return 1;
            }

            const hdr = buffer[pos + 1];
            let size = 2; // Base size (m_hdr + header byte)

            // Check for custom status bytes if status is SAM_LOG_UNKNOWN (30)
            if (status === 30) {
                size += 2; // 10-bit custom status
                addDebugMessage(`Action at ${pos}: +2 bytes for custom status`);
            }

            // Add size for other fields based on header bits
            if (hdr & SAM_LOG_HDR.SLOT_IDX) {
                size += 3;
                addDebugMessage(`Action at ${pos}: +3 bytes for SLOT_IDX`);
            }

            if (hdr & SAM_LOG_HDR.SLOT_IDX_DIFF) {
                size += 2;
                addDebugMessage(`Action at ${pos}: +2 bytes for SLOT_IDX_DIFF`);
            }

            if (hdr & SAM_LOG_HDR.SLOTS_TO_USE) {
                size += 1;
                addDebugMessage(`Action at ${pos}: +1 byte for SLOTS_TO_USE`);
            }

            // Add size for custom data length field and data if present
            if (hdr & SAM_LOG_HDR.CUSTOM_FIELDS) {
                size += 2;

                if (pos + size <= buffer.length) {
                    const customLen = (buffer[pos + size - 2] << 8) | buffer[pos + size - 1];
                    size += customLen;
                    addDebugMessage(`Action at ${pos}: +${customLen} bytes for custom data, total size = ${size}`);
                } else {
                    addDebugMessage(`Action at ${pos}: Buffer too short for custom data length`);
                }
            }

            return size;
        }

        // Parse a single action
        function parseAction(buffer, pos, defaultSlotsToUse, currentSlotIdx) {
            const startPos = pos;
            const firstByte = buffer[pos++];
            const m_hdr = (firstByte & 0x80) >> 7;
            const status = firstByte & 0x1F;

            addDebugMessage(`Parsing action at ${startPos}: status=${status} (${STATUS_NAMES[status] || 'Unknown'}), m_hdr=${m_hdr}`);

            // Create action object
            const action = {
                status,
                statusName: STATUS_NAMES[status] || `Unknown (${status})`,
                m_hdr,
                slotIdx: currentSlotIdx,
                slotsToUse: defaultSlotsToUse,
                startPos
            };

            // Process custom status for UNKNOWN (30)
            if (status === 30 && pos + 2 <= buffer.length) {
                const highByte = buffer[pos++];
                const lowByte = buffer[pos++];
                action.customStatus = (highByte << 2) | ((lowByte & 0xC0) >> 6);
            }

            // Process extended header if present
            if (m_hdr === 1 && pos < buffer.length) {
                const hdr = buffer[pos++];
                action.hdr = hdr;

                // Process slot index if present
                if ((hdr & SAM_LOG_HDR.SLOT_IDX) && pos + 3 <= buffer.length) {
                    action.slotIdx = (buffer[pos] << 16) | (buffer[pos + 1] << 8) | buffer[pos + 2];
                    pos += 3;
                }

                // Process slot difference if present
                if ((hdr & SAM_LOG_HDR.SLOT_IDX_DIFF) && pos + 2 <= buffer.length) {
                    let slotIdxDiff = (buffer[pos] << 8) | buffer[pos + 1];
                    if (slotIdxDiff & 0x8000) {
                        slotIdxDiff = -(0x10000 - slotIdxDiff);
                    }
                    action.slotIdxDiff = slotIdxDiff;
                    pos += 2;
                }

                // Process slots to use if present
                if ((hdr & SAM_LOG_HDR.SLOTS_TO_USE) && pos < buffer.length) {
                    action.slotsToUse = buffer[pos++];
                }

                // Process custom data
                if ((hdr & SAM_LOG_HDR.CUSTOM_FIELDS) && pos + 2 <= buffer.length) {
                    const customLen = (buffer[pos] << 8) | buffer[pos + 1];
                    action.customDataLength = customLen;
                    pos += 2;

                    // Extract custom data if available
                    if (customLen > 0 && pos + customLen <= buffer.length) {
                        action.customData = Array.from(buffer.slice(pos, pos + customLen))
                            .map(b => b.toString(16).padStart(2, '0'));
                        pos += customLen;
                    }
                }

                // Set scan flag if present
                if (hdr & SAM_LOG_HDR.SCAN) {
                    action.isScan = true;
                }

                // Flag if this sets default slots
                if (hdr & SAM_LOG_HDR.DEFAULT_SLOTS_TO_USE) {
                    action.setsDefaultSlots = true;
                }
            }

            return { action, newPos: pos };
        }

        // Parse SAM log data
        function parseLogData(buffer) {
            const actions = [];
            let defaultSlotsToUse = 1;
            let currentSlotIdx = 0;
            let pos = 0;

            if (!buffer || buffer.length === 0) {
                addDebugMessage("Empty buffer");
                return { actions };
            }

            addDebugMessage(`Buffer length: ${buffer.length} bytes`);

            // Process all valid actions
            while (pos < buffer.length) {
                // Check if this looks like a valid action header
                if (!isValidActionHeader(buffer, pos)) {
                    addDebugMessage(`Invalid header at position ${pos}, stopping parse`);
                    break;
                }

                // Determine total action length
                const actionLength = getActionTotalLength(buffer, pos);

                // Safety check - make sure we don't overrun the buffer
                if (pos + actionLength > buffer.length) {
                    addDebugMessage(`Action would extend beyond buffer end, stopping parse`);
                    break;
                }

                // Parse this action
                const { action, newPos } = parseAction(buffer, pos, defaultSlotsToUse, currentSlotIdx);

                // Validate the parsed action
                if (action.slotIdx > 1000000 || action.slotsToUse > 100) {
                    addDebugMessage(`Invalid slot values, stopping parse`);
                    break;
                }

                // Add the action
                actions.push(action);
                addDebugMessage(`Added action: ${action.statusName} at slot ${action.slotIdx}`);

                // Update tracking for next action
                if (action.status === 14) { // SYNCH_DONE
                    currentSlotIdx = action.slotIdx;
                } else {
                    currentSlotIdx = action.slotIdx + action.slotsToUse;
                }

                // Update default slots if specified
                if (action.setsDefaultSlots) {
                    defaultSlotsToUse = action.slotsToUse;
                }

                // Move to next action
                pos = newPos;

                // Safety check for infinite loops
                if (actions.length > 1000) {
                    addDebugMessage("Too many actions (>1000), stopping parse");
                    break;
                }
            }

            return { actions };
        }

        // Extract Z85 encoded portion from a log line
        function extractZ85Data(logLine) {
            // Find the LOG[x] part
            const logMatch = logLine.match(/LOG\[([^\]]+)\]\s+(START|END)\s+(\d+)\s+([^\s]+)/);

            if (logMatch) {
                const [_, logName, section, epochId, encodedData] = logMatch;
                addDebugMessage(`Found log: ${logName} ${section} ${epochId}`);

                // The encoded data should be the last token on the line
                // Extract just the Z85 token and verify it contains only valid Z85 characters
                const z85Part = encodedData;

                if (isValidZ85String(z85Part)) {
                    return {
                        logName,
                        section,
                        epochId: parseInt(epochId),
                        encodedData: z85Part
                    };
                } else {
                    addDebugMessage(`Invalid Z85 data: ${z85Part}`);
                }
            }

            return null;
        }

        // Parse SAM log lines
        function parseLog(logText) {
            const logs = [];
            const lines = logText.split('\n');

            addDebugMessage(`Processing ${lines.length} lines of input`);

            // Process each line
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === '') continue;

                // Look for log entries
                if (line.includes("LOG[") && line.includes("sam_log:")) {
                    const logInfo = extractZ85Data(line);

                    if (logInfo) {
                        try {
                            // Decode and parse the data
                            const decodedData = decodeZ85(logInfo.encodedData);

                            if (decodedData && decodedData.length > 0) {
                                const { actions } = parseLogData(decodedData);

                                if (actions.length > 0) {
                                    logs.push({
                                        ...logInfo,
                                        actions,
                                        decodedData
                                    });

                                    addDebugMessage(`Added log: ${logInfo.logName} with ${actions.length} actions`);
                                }
                            }
                        } catch (e) {
                            addDebugMessage(`Error processing log: ${e.message}`);
                            console.error("Error processing log:", e);
                        }
                    }
                }
            }

            return logs;
        }

        // Format header bits for display
        function formatHeaderBits(hdr) {
            if (hdr === undefined) return '';

            const bits = [];
            if (hdr & SAM_LOG_HDR.SLOT_IDX) bits.push('SLOT_IDX');
            if (hdr & SAM_LOG_HDR.SLOTS_TO_USE) bits.push('SLOTS_TO_USE');
            if (hdr & SAM_LOG_HDR.SLOT_IDX_DIFF) bits.push('SLOT_IDX_DIFF');
            if (hdr & SAM_LOG_HDR.SCAN) bits.push('SCAN');
            if (hdr & SAM_LOG_HDR.CUSTOM_FIELDS) bits.push('CUSTOM_FIELDS');
            if (hdr & SAM_LOG_HDR.DEFAULT_SLOTS_TO_USE) bits.push('DEFAULT_SLOTS_TO_USE');

            return bits.join(', ');
        }

        // Add debug message
        function addDebugMessage(message) {
            debugInfo.push(message);
        }

        // Display parsed results
        function displayResults(logs) {
            const resultDiv = document.getElementById('detailed-results');
            const summaryDiv = document.getElementById('summary-section');
            const debugDiv = document.getElementById('debug-info');

            // Update debug section
            debugDiv.innerHTML = `<h3>Debug Information</h3><pre>${debugInfo.join('\n')}</pre>`;
            debugDiv.style.display = debugMode ? 'block' : 'none';

            if (logs.length === 0) {
                resultDiv.innerHTML = '<p>No valid logs found.</p>';
                summaryDiv.innerHTML = '';
                return;
            }

            // Build summary section
            let summaryHtml = '<h2>Log Summary</h2>';
            logs.forEach((log, index) => {
                summaryHtml += `
                    <div class="summary-log" onclick="document.getElementById('log-section-${index}').scrollIntoView({behavior: 'smooth'})">
                        ${log.logName} - ${log.section} (Epoch ${log.epochId}): ${log.actions.length} actions
                    </div>
                `;
            });
            summaryDiv.innerHTML = summaryHtml;

            // Build detailed results
            let html = '';

            // Display results for each log
            logs.forEach((log, logIndex) => {
                html += `
                    <div id="log-section-${logIndex}" class="log-section">
                        <h2>Log: ${log.logName}, Section: ${log.section}, Epoch: ${log.epochId}</h2>
                        <p><strong>Found ${log.actions.length} actions</strong></p>
                `;

                // Show raw encoded data
                html += `
                    <details ${debugMode ? 'open' : ''}>
                        <summary>Z85 Encoded Data</summary>
                        <pre>${log.encodedData}</pre>
                    </details>
                `;

                // Show hex dump
                if (log.decodedData && log.decodedData.length > 0) {
                    html += `
                        <details ${debugMode ? 'open' : ''}>
                            <summary>Hex Dump</summary>
                            <pre>${hexDump(log.decodedData)}</pre>
                        </details>
                    `;
                }

                // Table of actions
                if (log.actions.length > 0) {
                    html += `
                        <table>
                            <thead>
                                <tr>
                                    <th>#</th>
                                    <th>Status</th>
                                    <th>Custom Status</th>
                                    <th>Header Bits</th>
                                    <th>Slot Index</th>
                                    <th>Slots To Use</th>
                                    <th>Sets Default</th>
                                    <th>Slot Diff</th>
                                    <th>Custom Data</th>
                                </tr>
                            </thead>
                            <tbody>
                    `;

                    // Add rows for each action
                    log.actions.forEach((action, index) => {
                        const rowClass = getStatusClass(action.status);

                        html += `
                            <tr class="${rowClass}">
                                <td>${index + 1}</td>
                                <td>${action.statusName} (${action.status})</td>
                                <td>${action.customStatus !== undefined ? action.customStatus : '-'}</td>
                                <td>${action.hdr !== undefined ? formatHeaderBits(action.hdr) : '-'}</td>
                                <td>${action.slotIdx !== undefined ? action.slotIdx : '-'}</td>
                                <td>${action.slotsToUse !== undefined ? action.slotsToUse : '1'}</td>
                                <td>${action.setsDefaultSlots ? 'Yes' : 'No'}</td>
                                <td>${action.slotIdxDiff !== undefined ? action.slotIdxDiff : '-'}</td>
                                <td class="custom-data">${action.customData ? action.customData.join(' ') : 'None'}</td>
                            </tr>
                        `;
                    });

                    html += `
                            </tbody>
                        </table>
                    `;
                } else {
                    html += `<p>No valid actions found in this log.</p>`;
                }

                html += `</div>`;
            });

            resultDiv.innerHTML = html;
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function () {
            // Clear debug info
            debugInfo.length = 0;

            const parseButton = document.getElementById('parse-button');
            const toggleDebugButton = document.getElementById('toggle-debug');
            const inputArea = document.getElementById('input');

            // Parse button handler
            parseButton.addEventListener('click', function () {
                // Clear debug info
                debugInfo.length = 0;
                const logs = parseLog(inputArea.value);
                displayResults(logs);
            });

            // Toggle debug mode
            toggleDebugButton.addEventListener('click', function () {
                debugMode = !debugMode;
                document.getElementById('debug-info').style.display = debugMode ? 'block' : 'none';
                displayResults(parseLog(inputArea.value));
            });
        });
    </script>
</body>

</html>