<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SAM Log Analyzer</title>
    <style>
        :root {
            --primary-color: #2a4d69;
            --primary-light: #4b79a1;
            --secondary-color: #f8f9fa;
            --border-color: #ddd;
            --error-color: #dc3545;

            /* Status colors */
            --rx-color: #d4edda;
            --tx-color: #d1ecf1;
            --sync-color: #cce5ff;
            --error-bg: #f8d7da;
        }

        /* Base styles */
        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 20px;
            background-color: #fff;
        }

        h1,
        h2,
        h3 {
            color: var(--primary-color);
            margin-top: 0;
        }

        h1 {
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        /* Controls */
        .controls {
            margin-bottom: 20px;
        }

        textarea {
            width: 100%;
            height: 200px;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-family: monospace;
            resize: vertical;
            margin-bottom: 10px;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 8px;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: var(--primary-light);
        }

        /* Results area */
        .result-container {
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 20px;
            background-color: white;
        }

        .debug-section {
            background-color: var(--secondary-color);
            border-left: 4px solid var(--error-color);
            padding: 15px;
            margin-bottom: 20px;
            overflow: auto;
        }

        .summary-log {
            padding: 10px;
            background-color: var(--secondary-color);
            border-left: 4px solid var(--primary-color);
            margin-bottom: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .summary-log:hover {
            background-color: #e9ecef;
        }

        .log-section {
            margin-bottom: 30px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 20px;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 14px;
        }

        th,
        td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        th {
            background-color: var(--secondary-color);
            font-weight: 600;
        }

        /* Status colors */
        .status-rx {
            background-color: var(--rx-color);
        }

        .status-tx {
            background-color: var(--tx-color);
        }

        .status-sync {
            background-color: var(--sync-color);
        }

        .status-error {
            background-color: var(--error-bg);
        }

        /* Custom data */
        .custom-data {
            font-family: monospace;
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            transition: all 0.3s;
        }

        .custom-data:hover {
            white-space: normal;
            overflow: visible;
        }

        /* Code and pre */
        pre,
        code {
            font-family: SFMono-Regular, Menlo, Monaco, Consolas, monospace;
            font-size: 13px;
        }

        pre {
            background-color: #f5f5f5;
            padding: 12px;
            border-radius: 4px;
            overflow: auto;
            white-space: pre;
        }

        /* Details/summary */
        details {
            margin-bottom: 15px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
        }

        summary {
            padding: 10px;
            background-color: var(--secondary-color);
            cursor: pointer;
            font-weight: 600;
        }

        details[open] summary {
            border-bottom: 1px solid var(--border-color);
        }
    </style>
</head>

<body>
    <h1>SAM Log Analyzer</h1>

    <div class="controls">
        <p>Paste your SAM log output below to analyze the encoded data:</p>
        <textarea id="input-area" placeholder="Paste SAM log here..." spellcheck="false"></textarea>
        <button id="parse-btn">Parse Logs</button>
        <button id="toggle-debug-btn">Toggle Debug Info</button>
    </div>

    <div class="result-container">
        <div id="debug-panel" class="debug-section" style="display:none;"></div>
        <div id="summary-panel"></div>
        <div id="results-panel"></div>
    </div>

    <script>
        /**
         * SAM Log Viewer
         * A utility for parsing and visualizing SAM protocol logs.
         */
        (function () {
            // DOM Elements
            const elements = {
                inputArea: document.getElementById('input-area'),
                parseBtn: document.getElementById('parse-btn'),
                toggleDebugBtn: document.getElementById('toggle-debug-btn'),
                debugPanel: document.getElementById('debug-panel'),
                summaryPanel: document.getElementById('summary-panel'),
                resultsPanel: document.getElementById('results-panel')
            };

            // Application state
            const state = {
                debugMode: false,
                debugMessages: [],
                currentLogs: []
            };

            // Constants
            const CONSTANTS = {
                MAX_ACTIONS: 1000,
                SYNCH_DONE_STATUS: 14,
                UNKNOWN_STATUS: 30,
                STATUS_NAMES: {
                    0: 'RX_SUCCESS', 1: 'RX_TIMEOUT', 2: 'RX_ERROR', 3: 'RX_MALFORMED',
                    4: 'RX_LISTEN_LATE', 5: 'RX_LISTEN_FAIL', 6: 'TIMER_EVENT', 7: 'TX_DONE',
                    8: 'TX_SCHED_LATE', 9: 'TX_SCHED_FAIL', 14: 'SYNCH_DONE',
                    15: 'SYNCH_FAIL', 16: 'SKIP_SUCCESS', 17: 'RESTART_LATE',
                    18: 'RESTART_FAIL', 30: 'UNKNOWN'
                },
                HEADER_FLAGS: {
                    SLOT_IDX: 0x01,
                    SLOTS_TO_USE: 0x02,
                    SLOT_IDX_DIFF: 0x04,
                    SCAN: 0x08,
                    CUSTOM_FIELDS: 0x10,
                    DEFAULT_SLOTS_TO_USE: 0x20
                },
                // Bit masks
                MASKS: {
                    M_HDR: 0x80,
                    STATUS: 0x7C,
                    CUSTOM_STATUS_HIGH: 0x03
                }
            };

            // Z85 Decoder implementation
            const Z85 = {
                // Z85 character set
                CHARSET: "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-:+=^!/*?&<>()[]{}@%$#",

                // Validates if a string contains only Z85 characters
                isValid(str) {
                    if (!str || typeof str !== 'string') return false;

                    for (let i = 0; i < str.length; i++) {
                        if (this.CHARSET.indexOf(str[i]) === -1) {
                            return false;
                        }
                    }
                    return true;
                },

                // Decodes a Z85 string to binary data
                decode(encoded) {
                    if (!encoded || encoded.length === 0) {
                        debug("Empty Z85 input");
                        return new Uint8Array(0);
                    }

                    // Validate input
                    if (!this.isValid(encoded)) {
                        debug("Invalid Z85 characters in input");
                        return new Uint8Array(0);
                    }

                    debug(`Decoding Z85 string (length ${encoded.length})`);

                    // Build lookup table for faster decoding
                    const lookup = {};
                    for (let i = 0; i < this.CHARSET.length; i++) {
                        lookup[this.CHARSET[i]] = i;
                    }

                    // Check for padding marker
                    const paddingDigit = parseInt(encoded.charAt(0));
                    let encodedData = encoded;
                    let hasPadding = false;

                    if (!isNaN(paddingDigit) && paddingDigit >= 1 && paddingDigit <= 4) {
                        encodedData = encoded.substring(1);
                        hasPadding = true;
                        debug(`Found padding marker: ${paddingDigit}`);
                    }

                    // Ensure length is multiple of 5
                    if (encodedData.length % 5 !== 0) {
                        const excess = encodedData.length % 5;
                        encodedData = encodedData.substring(0, encodedData.length - excess);
                        debug(`Truncated ${excess} chars to make multiple of 5`);
                    }

                    if (encodedData.length === 0) {
                        debug("No valid encoded data after adjustments");
                        return new Uint8Array(0);
                    }

                    // Calculate decoded length
                    const numChunks = encodedData.length / 5;
                    const decodedLength = numChunks * 4;
                    debug(`Will decode ${numChunks} chunks to produce ${decodedLength} bytes`);

                    const result = new Uint8Array(decodedLength);

                    // Process each 5-character chunk
                    for (let i = 0, destIndex = 0; i < encodedData.length; i += 5) {
                        if (i + 5 > encodedData.length) break;

                        // Convert 5 characters to an integer value
                        let value = 0;
                        for (let j = 0; j < 5; j++) {
                            value = value * 85 + lookup[encodedData[i + j]];
                        }

                        // Extract 4 bytes from the integer
                        result[destIndex++] = (value >> 24) & 0xFF;
                        result[destIndex++] = (value >> 16) & 0xFF;
                        result[destIndex++] = (value >> 8) & 0xFF;
                        result[destIndex++] = value & 0xFF;
                    }

                    // Handle padding if present
                    if (hasPadding) {
                        const outputSize = (numChunks - 1) * 4 + paddingDigit;
                        debug(`Applying padding: final size = ${outputSize} bytes`);
                        return result.slice(0, outputSize);
                    }

                    return result;
                }
            };

            /**
             * Add a debug message
             */
            function debug(message) {
                state.debugMessages.push(message);
                if (state.debugMode) {
                    console.log(message);
                }
            }

            /**
             * Format binary data as a hex dump
             */
            function createHexDump(data) {
                if (!data || data.length === 0) return "Empty data";

                const HEX_CHARS = "0123456789ABCDEF";
                const BYTES_PER_LINE = 16;
                let output = [];

                for (let offset = 0; offset < data.length; offset += BYTES_PER_LINE) {
                    // Address column
                    let line = offset.toString(16).padStart(8, '0') + ": ";

                    // Hex columns
                    const lineEnd = Math.min(offset + BYTES_PER_LINE, data.length);
                    for (let i = offset; i < lineEnd; i++) {
                        const byte = data[i];
                        line += HEX_CHARS[(byte >> 4) & 0xF] + HEX_CHARS[byte & 0xF] + " ";
                    }

                    // Padding if not a full line
                    if (lineEnd < offset + BYTES_PER_LINE) {
                        line += "   ".repeat(offset + BYTES_PER_LINE - lineEnd);
                    }

                    // ASCII representation
                    line += " | ";
                    for (let i = offset; i < lineEnd; i++) {
                        const byte = data[i];
                        line += (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
                    }

                    output.push(line);
                }

                return output.join('\n');
            }

            /**
             * Get CSS class for an action status
             */
            function getStatusClass(status) {
                if ([0, 1, 4].includes(status)) return 'status-rx';
                if (status === 7) return 'status-tx';
                if (status === CONSTANTS.SYNCH_DONE_STATUS) return 'status-sync';
                if ([2, 3, 15].includes(status)) return 'status-error';
                return '';
            }

            /**
             * Format header bits as a readable string
             */
            function formatHeaderBits(hdr) {
                if (hdr === undefined) return '-';

                const flagNames = [];
                if (hdr & CONSTANTS.HEADER_FLAGS.SLOT_IDX) flagNames.push('SLOT_IDX');
                if (hdr & CONSTANTS.HEADER_FLAGS.SLOTS_TO_USE) flagNames.push('SLOTS_TO_USE');
                if (hdr & CONSTANTS.HEADER_FLAGS.SLOT_IDX_DIFF) flagNames.push('SLOT_IDX_DIFF');
                if (hdr & CONSTANTS.HEADER_FLAGS.SCAN) flagNames.push('SCAN');
                if (hdr & CONSTANTS.HEADER_FLAGS.CUSTOM_FIELDS) flagNames.push('CUSTOM_FIELDS');
                if (hdr & CONSTANTS.HEADER_FLAGS.DEFAULT_SLOTS_TO_USE) flagNames.push('DEFAULT_SLOTS_TO_USE');

                return flagNames.length > 0 ? flagNames.join(', ') : '-';
            }

            /**
             * Check if a buffer position contains a valid action header
             */
            function hasValidHeader(buffer, pos) {
                if (pos >= buffer.length) {
                    debug(`Position ${pos} is beyond buffer end (${buffer.length})`);
                    return false;
                }

                // First byte contains m_hdr and status
                const firstByte = buffer[pos];
                const m_hdr = (firstByte & CONSTANTS.MASKS.M_HDR) >> 7;
                const status = (firstByte & CONSTANTS.MASKS.STATUS) >> 2;

                // Validate status
                if (status > 30) {
                    debug(`Invalid status value: ${status}`);
                    return false;
                }

                // If extended header, validate header byte
                if (m_hdr === 1) {
                    if (pos + 1 >= buffer.length) {
                        debug(`Not enough bytes for extended header`);
                        return false;
                    }

                    // If status is UNKNOWN, we expect custom status which takes another byte
                    if (status === CONSTANTS.UNKNOWN_STATUS && pos + 2 >= buffer.length) {
                        debug(`Not enough bytes for custom status`);
                        return false;
                    }

                    const hdrPos = (status === CONSTANTS.UNKNOWN_STATUS) ? pos + 2 : pos + 1;

                    if (hdrPos >= buffer.length) {
                        debug(`Not enough bytes for header`);
                        return false;
                    }

                    const hdr = buffer[hdrPos];
                    if (hdr > 63) {
                        debug(`Invalid header value: ${hdr}`);
                        return false;
                    }
                }

                return true;
            }

            /**
             * Calculate total length of an action at buffer position
             */
            function getActionLength(buffer, pos) {
                const firstByte = buffer[pos];
                const m_hdr = (firstByte & CONSTANTS.MASKS.M_HDR) >> 7;
                const status = (firstByte & CONSTANTS.MASKS.STATUS) >> 2;

                // Simple action with no extended header
                if (m_hdr === 0) {
                    return 1;
                }

                // For custom status, we need an extra byte
                let offset = 1;
                if (status === CONSTANTS.UNKNOWN_STATUS) {
                    offset = 2;
                }

                // Extended header
                if (pos + offset >= buffer.length) {
                    debug(`Buffer too short for extended header at ${pos}`);
                    return offset;
                }

                const hdr = buffer[pos + offset];
                let size = offset + 1;  // Base size with header

                // Add size for each field based on header bits
                if (hdr & CONSTANTS.HEADER_FLAGS.SLOT_IDX) {
                    size += 3;  // 24-bit slot index
                }

                if (hdr & CONSTANTS.HEADER_FLAGS.SLOT_IDX_DIFF) {
                    size += 2;  // 16-bit slot index difference
                }

                if (hdr & CONSTANTS.HEADER_FLAGS.SLOTS_TO_USE) {
                    size += 1;  // 8-bit slots to use
                }

                // Add custom data size if present
                if (hdr & CONSTANTS.HEADER_FLAGS.CUSTOM_FIELDS) {
                    size += 2;  // 16-bit length field

                    // Read the custom data length
                    if (pos + size <= buffer.length) {
                        const customLength = (buffer[pos + size - 2] << 8) | buffer[pos + size - 1];
                        size += customLength;
                        debug(`Action at ${pos} has ${customLength} bytes of custom data`);
                    }
                }

                return size;
            }

            /**
             * Parse a single action from the buffer
             */
            function parseAction(buffer, pos, defaultSlotsToUse, currentSlotIdx) {
                const startPos = pos;

                // Read first byte: m_hdr and status
                const firstByte = buffer[pos++];
                const m_hdr = (firstByte & CONSTANTS.MASKS.M_HDR) >> 7;
                const status = (firstByte & CONSTANTS.MASKS.STATUS) >> 2;

                // Create base action object
                const action = {
                    status,
                    statusName: CONSTANTS.STATUS_NAMES[status] || `Unknown (${status})`,
                    slotIdx: currentSlotIdx,
                    slotsToUse: defaultSlotsToUse
                };

                // Process custom status if present
                if (status === CONSTANTS.UNKNOWN_STATUS) {
                    if (pos < buffer.length) {
                        // Get high 2 bits from first byte (bits 0-1) and low 8 bits from second byte
                        const highBits = firstByte & CONSTANTS.MASKS.CUSTOM_STATUS_HIGH;
                        const lowBits = buffer[pos++];
                        action.customStatus = (highBits << 8) | lowBits;
                        debug(`Custom status: ${action.customStatus}`);
                    } else {
                        debug(`Buffer too short for custom status`);
                    }
                }

                // Process extended header if present
                if (m_hdr === 1 && pos < buffer.length) {
                    const hdr = buffer[pos++];
                    action.hdr = hdr;

                    // Process slot index
                    if ((hdr & CONSTANTS.HEADER_FLAGS.SLOT_IDX) && pos + 3 <= buffer.length) {
                        action.slotIdx = (buffer[pos] << 16) | (buffer[pos + 1] << 8) | buffer[pos + 2];
                        pos += 3;
                    }

                    // Process slot index difference
                    if ((hdr & CONSTANTS.HEADER_FLAGS.SLOT_IDX_DIFF) && pos + 2 <= buffer.length) {
                        let diff = (buffer[pos] << 8) | buffer[pos + 1];
                        // Handle sign bit
                        if (diff & 0x8000) {
                            diff = -(0x10000 - diff);
                        }
                        action.slotIdxDiff = diff;
                        pos += 2;
                    }

                    // Process slots to use
                    if ((hdr & CONSTANTS.HEADER_FLAGS.SLOTS_TO_USE) && pos < buffer.length) {
                        action.slotsToUse = buffer[pos++];
                    }

                    // Process custom data
                    if ((hdr & CONSTANTS.HEADER_FLAGS.CUSTOM_FIELDS) && pos + 2 <= buffer.length) {
                        const dataLength = (buffer[pos] << 8) | buffer[pos + 1];
                        action.customDataLength = dataLength;
                        pos += 2;

                        // Extract the custom data if available
                        if (dataLength > 0 && pos + dataLength <= buffer.length) {
                            action.customData = Array.from(buffer.slice(pos, pos + dataLength))
                                .map(b => b.toString(16).padStart(2, '0'));
                            pos += dataLength;
                        }
                    }

                    // Set flags
                    if (hdr & CONSTANTS.HEADER_FLAGS.SCAN) {
                        action.isScan = true;
                    }

                    if (hdr & CONSTANTS.HEADER_FLAGS.DEFAULT_SLOTS_TO_USE) {
                        action.setsDefaultSlots = true;
                    }
                }

                debug(`Parsed action: ${action.statusName} at slot ${action.slotIdx}`);
                return { action, newPos: pos };
            }

            /**
             * Parse binary log data into action objects
             */
            function parseLogData(buffer) {
                if (!buffer || buffer.length === 0) {
                    debug("Empty buffer");
                    return { actions: [] };
                }

                const actions = [];
                let defaultSlotsToUse = 1;
                let currentSlotIdx = 0;
                let pos = 0;

                debug(`Parsing buffer of ${buffer.length} bytes`);

                while (pos < buffer.length) {
                    // Validate action header
                    if (!hasValidHeader(buffer, pos)) {
                        debug(`Invalid header at ${pos}, stopping parse`);
                        break;
                    }

                    // Get action length
                    const actionLength = getActionLength(buffer, pos);

                    // Ensure we have enough buffer
                    if (pos + actionLength > buffer.length) {
                        debug(`Action at ${pos} would exceed buffer bounds`);
                        break;
                    }

                    // Parse the action
                    const { action, newPos } = parseAction(buffer, pos, defaultSlotsToUse, currentSlotIdx);

                    // Sanity check parsed values
                    if (action.slotIdx > 1000000 || action.slotsToUse > 100) {
                        debug(`Unreasonable slot values detected, stopping parse`);
                        break;
                    }

                    // Add action to results
                    actions.push(action);

                    // Update current slot tracking
                    if (action.status === CONSTANTS.SYNCH_DONE_STATUS) {
                        currentSlotIdx = action.slotIdx;
                    } else {
                        currentSlotIdx = action.slotIdx + action.slotsToUse;
                    }

                    // Update default slots if specified
                    if (action.setsDefaultSlots) {
                        defaultSlotsToUse = action.slotsToUse;
                    }

                    // Move to next action
                    pos = newPos;

                    // Safety check
                    if (actions.length >= CONSTANTS.MAX_ACTIONS) {
                        debug(`Maximum actions limit (${CONSTANTS.MAX_ACTIONS}) reached`);
                        break;
                    }
                }

                debug(`Found ${actions.length} actions`);
                return { actions };
            }

            /**
             * Extract Z85 log data from a log line
             */
            function extractZ85Data(line) {
                const logMatch = line.match(/LOG\[([^\]]+)\]\s+(START|END)\s+(\d+)\s+(.+)/);

                if (!logMatch) return null;

                const [_, logName, section, epochId, encodedData] = logMatch;

                const cleanedEncoded = encodedData.replace(/\s+/g, '');  // Just in case

                if (!Z85.isValid(cleanedEncoded)) {
                    debug(`Invalid Z85 data in log: ${cleanedEncoded.substring(0, 20)}...`);
                    return null;
                }

                debug(`Found log: ${logName} ${section} ${epochId}`);

                return {
                    logName,
                    section,
                    epochId: parseInt(epochId),
                    encodedData: cleanedEncoded
                };
            }

            /**
             * Process full log text and parse all log entries
             */
             function processLogText(text) {
                if (!text || typeof text !== 'string') {
                    return [];
                }

                const logs = [];
                const lines = text.split('\n');
                // now matches “[hh:mm:ss.mmm,uuu] …”
                const timestampRe = /^\[\d{2}:\d{2}:\d{2}\.\d{3},\d{3}\]/;

                for (let i = 0; i < lines.length; i++) {
                    let line = lines[i].trim();
                    if (!line.startsWith('LOG[')) {
                        continue;
                    }

                    // collect the LOG[...] line plus any wrapped Z85 lines
                    let block = line;
                    let j = i + 1;
                    while (j < lines.length && !timestampRe.test(lines[j].trim())) {
                        block += ' ' + lines[j].trim();
                        j++;
                    }
                    i = j - 1;

                    block = block.replace(/\s+/g, ' ');

                    const logInfo = extractZ85Data(block);
                    if (!logInfo) continue;

                    try {
                        const decodedData = Z85.decode(logInfo.encodedData);
                        if (!decodedData || decodedData.length === 0) continue;

                        const { actions } = parseLogData(decodedData);
                        if (!actions || actions.length === 0) continue;

                        logs.push({ ...logInfo, actions, decodedData });
                    } catch (e) {
                        debug(`Error processing log "${logInfo.logName}": ${e.message}`);
                        console.error(e);
                    }
                }

                debug(`Found ${logs.length} valid logs`);
                return logs;
            }

            /**
             * Render log summary
             */
            function renderSummary(logs) {
                if (!logs || logs.length === 0) {
                    elements.summaryPanel.innerHTML = '<p>No valid logs found.</p>';
                    return;
                }

                let html = '<h2>Log Summary</h2>';

                logs.forEach((log, index) => {
                    html += `
                    <div class="summary-log" data-log-index="${index}">
                        ${log.logName} - ${log.section} (Epoch ${log.epochId}): ${log.actions.length} actions
                    </div>
                `;
                });

                elements.summaryPanel.innerHTML = html;

                // Add click handlers
                document.querySelectorAll('.summary-log').forEach(el => {
                    el.addEventListener('click', () => {
                        const logIndex = el.getAttribute('data-log-index');
                        document.getElementById(`log-section-${logIndex}`).scrollIntoView({
                            behavior: 'smooth'
                        });
                    });
                });
            }

            /**
             * Render detailed log sections
             */
            function renderDetails(logs) {
                if (!logs || logs.length === 0) {
                    elements.resultsPanel.innerHTML = '';
                    return;
                }

                let html = '';

                logs.forEach((log, logIndex) => {
                    html += `
                    <div id="log-section-${logIndex}" class="log-section">
                        <h2>Log: ${log.logName}, Section: ${log.section}, Epoch: ${log.epochId}</h2>
                        <p><strong>Found ${log.actions.length} actions</strong></p>
                `;

                    // Z85 encoded data
                    html += `
                    <details ${state.debugMode ? 'open' : ''}>
                        <summary>Z85 Encoded Data</summary>
                        <pre>${log.encodedData}</pre>
                    </details>
                `;

                    // Hex dump of decoded data
                    if (log.decodedData && log.decodedData.length > 0) {
                        html += `
                        <details ${state.debugMode ? 'open' : ''}>
                            <summary>Binary Data (Hex Dump)</summary>
                            <pre>${createHexDump(log.decodedData)}</pre>
                        </details>
                    `;
                    }

                    // Actions table
                    if (log.actions.length > 0) {
                        html += `
                        <table>
                            <thead>
                                <tr>
                                    <th>#</th>
                                    <th>Status</th>
                                    <th>Custom Status</th>
                                    <th>Header Bits</th>
                                    <th>Slot Index</th>
                                    <th>Slots To Use</th>
                                    <th>Sets Default</th>
                                    <th>Slot Diff</th>
                                    <th>Custom Data</th>
                                </tr>
                            </thead>
                            <tbody>
                    `;
                        let end_slot_idx_unknown = false;
                        if(log.section === 'END' ){
                            end_slot_idx_unknown = true;
                        }
                        // Add rows for each action
                        log.actions.forEach((action, index) => {
                            const rowClass = getStatusClass(action.status);

                            if (action.hdr & CONSTANTS.HEADER_FLAGS.SLOT_IDX) {
                                end_slot_idx_unknown = false;
                            }

                            html += `
                            <tr class="${rowClass}">
                                <td>${index + 1}</td>
                                <td>${action.statusName} (${action.status})</td>
                                <td>${action.customStatus !== undefined ? action.customStatus : '-'}</td>
                                <td>${formatHeaderBits(action.hdr)}</td>
                                <td>${
                                  (!end_slot_idx_unknown)
                                    ? action.slotIdx
                                    : `x + ${action.slotIdx}`
                                }</td>
                                <td>${action.slotsToUse}</td>
                                <td>${action.setsDefaultSlots ? 'Yes' : 'No'}</td>
                                <td>${action.slotIdxDiff !== undefined ? action.slotIdxDiff : '-'}</td>
                                <td class="custom-data">${action.customData ? action.customData.join(' ') : '-'}</td>
                            </tr>
                        `;
                        });

                        html += `
                            </tbody>
                        </table>
                    `;
                    } else {
                        html += `<p>No valid actions found in this log.</p>`;
                    }

                    html += `</div>`;
                });

                elements.resultsPanel.innerHTML = html;
            }

            /**
             * Update debug panel
             */
            function updateDebugPanel() {
                if (state.debugMessages.length === 0) {
                    elements.debugPanel.innerHTML = '';
                    return;
                }

                elements.debugPanel.innerHTML = `
                <h3>Debug Information</h3>
                <pre>${state.debugMessages.join('\n')}</pre>
            `;
                elements.debugPanel.style.display = state.debugMode ? 'block' : 'none';
            }

            /**
             * Main parser function
             */
            function parseAndRender() {
                // Reset state
                state.debugMessages = [];

                // Get input text
                const inputText = elements.inputArea.value.trim();
                if (!inputText) {
                    elements.summaryPanel.innerHTML = '<p>No input provided.</p>';
                    elements.resultsPanel.innerHTML = '';
                    return;
                }

                // Process logs
                const logs = processLogText(inputText);
                state.currentLogs = logs;

                // Update UI
                updateDebugPanel();
                renderSummary(logs);
                renderDetails(logs);
            }

            /**
             * Toggle debug mode
             */
            function toggleDebugMode() {
                state.debugMode = !state.debugMode;
                elements.debugPanel.style.display = state.debugMode ? 'block' : 'none';

                // Re-render current logs with new debug setting
                renderDetails(state.currentLogs);
            }

            /**
             * Initialize the application
             */
            function initialize() {
                // Set up event listeners
                elements.parseBtn.addEventListener('click', parseAndRender);
                elements.toggleDebugBtn.addEventListener('click', toggleDebugMode);

                // Initial UI setup
                elements.debugPanel.style.display = 'none';
                elements.summaryPanel.innerHTML = '<p>Enter log data and click "Parse Logs"</p>';
            }

            // Initialize when DOM is ready
            initialize();
        })();
    </script>
</body>

</html>