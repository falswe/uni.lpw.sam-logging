<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SAM Log Analyzer</title>
    <style>
        body {
            font-family: system-ui, sans-serif;
            margin: 20px;
            line-height: 1.5;
        }

        h1,
        h2 {
            color: #2a4d69;
        }

        textarea {
            width: 100%;
            height: 200px;
            margin: 10px 0;
            padding: 8px;
            font-family: monospace;
        }

        .result {
            border: 1px solid #ccc;
            padding: 15px;
            margin-top: 20px;
            border-radius: 4px;
        }

        .summary-log {
            margin: 5px 0;
            padding: 8px;
            background-color: #f8f9fa;
            border-left: 4px solid #2a4d69;
            cursor: pointer;
        }

        .summary-log:hover {
            background-color: #e9ecef;
        }

        .log-section {
            margin-bottom: 30px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 20px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th,
        td {
            text-align: left;
            padding: 8px;
            border-bottom: 1px solid #ddd;
        }

        th {
            background-color: #f2f2f2;
        }

        .custom-data {
            font-family: monospace;
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .custom-data:hover {
            white-space: normal;
            overflow: visible;
        }

        pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            overflow: auto;
            font-family: monospace;
        }

        .binary-view {
            font-family: monospace;
            line-height: 1.3;
        }

        .binary-byte {
            color: #0066cc;
            margin-right: 5px;
        }

        .binary-byte-divider {
            color: #999;
            margin: 0 2px;
        }

        .status-rx {
            background-color: #d4edda;
        }

        .status-tx {
            background-color: #d1ecf1;
        }

        .status-error {
            background-color: #f8d7da;
        }

        .status-sync {
            background-color: #cce5ff;
        }

        .button {
            padding: 8px 12px;
            background-color: #2a4d69;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }
    </style>
</head>

<body>
    <h1>SAM Log Analyzer</h1>
    <p>Paste your SAM log output below to analyze the encoded data:</p>

    <textarea id="input" placeholder="Paste SAM log here..."></textarea>
    <button class="button" id="parse-button">Parse Logs</button>

    <div class="result">
        <div id="summary-section"></div>
        <div id="detailed-results"></div>
    </div>

    <script>
        // Z85 decoder
        function decodeZ85(encoded) {
            if (!encoded || encoded.length === 0) return new Uint8Array(0);
            encoded = encoded.replace(/\s+/g, "");

            const base85 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-:+=^!/*?&<>()[]{}@%$#";
            const lookup = {};
            for (let i = 0; i < base85.length; i++) lookup[base85[i]] = i;

            const paddingDigit = parseInt(encoded.charAt(0));
            let encodedData = encoded;
            let padding = 0;

            if (!isNaN(paddingDigit) && paddingDigit >= 1 && paddingDigit <= 4) {
                encodedData = encoded.substring(1);
                padding = 4 - paddingDigit;
            }

            if (encodedData.length % 5 !== 0) {
                const extra = encodedData.length % 5;
                encodedData = encodedData.substring(0, encodedData.length - extra);
            }

            if (encodedData.length === 0) return new Uint8Array(0);

            const decodedLength = Math.floor(encodedData.length * 4 / 5);
            const result = new Uint8Array(decodedLength);

            let j = 0;
            for (let i = 0; i < encodedData.length; i += 5) {
                if (i + 4 >= encodedData.length) break;

                const chars = [
                    encodedData[i], encodedData[i + 1], encodedData[i + 2],
                    encodedData[i + 3], encodedData[i + 4]
                ];

                if (chars.some(char => lookup[char] === undefined)) continue;

                let value = 0;
                for (let k = 0; k < 5; k++) value = value * 85 + lookup[encodedData[i + k]];

                if (j + 3 < result.length) {
                    result[j] = (value >> 24) & 0xFF;
                    result[j + 1] = (value >> 16) & 0xFF;
                    result[j + 2] = (value >> 8) & 0xFF;
                    result[j + 3] = value & 0xFF;
                    j += 4;
                }
            }

            if (!isNaN(paddingDigit) && paddingDigit < 4) {
                return result.slice(0, decodedLength - padding);
            }

            return result;
        }

        // Create hex dump of binary data
        function hexDump(data) {
            const hexChars = '0123456789ABCDEF';
            let output = '';

            for (let i = 0; i < data.length; i++) {
                if (i % 16 === 0) {
                    if (i > 0) {
                        output += ' | ' + [...data.subarray(i - 16, i)].map(b => (b >= 32 && b <= 126) ?
                            String.fromCharCode(b) : '.').join('') + '\n';
                    }
                    output += (i).toString(16).padStart(4, '0') + ': ';
                }

                const byte = data[i];
                output += hexChars[(byte >> 4) & 0xF] + hexChars[byte & 0xF] + ' ';
            }

            // Add the last line if there's anything left
            if (output.endsWith(' ')) {
                const lastLineStart = Math.floor(data.length / 16) * 16;
                const padding = ' '.repeat(3 * (16 - (data.length % 16)));

                if (data.length % 16 !== 0) {
                    output += padding;
                }

                output += ' | ' + [...data.subarray(lastLineStart)].map(b =>
                    (b >= 32 && b <= 126) ? String.fromCharCode(b) : '.').join('');
            }

            return output;
        }

        // SAM Log parsing constants
        const SAM_LOG_HDR = {
            SLOT_IDX: (1 << 0),
            SLOTS_TO_USE: (1 << 1),
            SLOT_IDX_DIFF: (1 << 2),
            SCAN: (1 << 3),
            CUSTOM_FIELDS: (1 << 4),
            DEFAULT_SLOTS_TO_USE: (1 << 5)
        };

        const STATUS_NAMES = {
            0: 'RX_SUCCESS', 1: 'RX_TIMEOUT', 2: 'RX_ERROR', 3: 'RX_MALFORMED',
            4: 'RX_LISTEN_LATE', 5: 'RX_LISTEN_FAIL', 6: 'TIMER_EVENT', 7: 'TX_DONE',
            8: 'TX_SCHED_LATE', 9: 'TX_SCHED_FAIL', 14: 'SYNCH_DONE',
            15: 'SYNCH_FAIL', 16: 'SKIP_SUCCESS', 17: 'RESTART_LATE', 18: 'RESTART_FAIL',
            19: 'UNKNOWN'
        };

        // Get the CSS class for a status value
        function getStatusClass(status) {
            if (status === 0 || status === 1 || status === 4) return 'status-rx';
            if (status === 7) return 'status-tx';
            if (status === 14) return 'status-sync';
            if (status === 2 || status === 3 || status === 15) return 'status-error';
            return '';
        }

        // Validate action header
        function isValidActionHeader(buffer, pos) {
            if (pos >= buffer.length) return false;

            // First byte: check m_hdr and status
            const firstByte = buffer[pos];
            const m_hdr = (firstByte & 0x80) >> 7;
            const status = firstByte & 0x1F;

            // Status must be in range 0-19, and reserved bits must be 0
            if (status > 19 || (firstByte & 0x60) !== 0) return false;

            // If m_hdr is set, we need enough bytes for header
            if (m_hdr === 1) {
                if (pos + 1 >= buffer.length) return false;
                // Check header byte - must be a reasonable value
                if (buffer[pos + 1] > 63) return false;
            }

            return true;
        }

        // Get the total length of an action (header + custom data)
        function getActionTotalLength(buffer, pos) {
            const firstByte = buffer[pos];
            const m_hdr = (firstByte & 0x80) >> 7;
            const status = firstByte & 0x1F;

            // If no m_hdr, just the status byte
            if (m_hdr === 0) return 1;

            // Header byte is at position pos+1
            if (pos + 1 >= buffer.length) return 1;

            const hdr = buffer[pos + 1];
            let size = 2; // Base size (m_hdr + header byte)

            // Check for custom status bytes if status is SAM_LOG_UNKNOWN (19)
            if (status === 19) size += 2; // 10-bit custom status

            // Add size for other fields based on header bits
            if (hdr & SAM_LOG_HDR.SLOT_IDX) size += 3;
            if (hdr & SAM_LOG_HDR.SLOT_IDX_DIFF) size += 2;
            if (hdr & SAM_LOG_HDR.SLOTS_TO_USE) size += 1;

            // Add size for custom data length field and data if present
            if (hdr & SAM_LOG_HDR.CUSTOM_FIELDS) {
                size += 2;
                if (pos + size <= buffer.length) {
                    const customLen = (buffer[pos + size - 2] << 8) | buffer[pos + size - 1];
                    size += customLen;
                }
            }

            return size;
        }

        // Parse a single action
        function parseAction(buffer, pos, defaultSlotsToUse, currentSlotIdx) {
            const startPos = pos;
            const firstByte = buffer[pos++];
            const m_hdr = (firstByte & 0x80) >> 7;
            const status = firstByte & 0x1F;

            // Create action object
            const action = {
                status,
                statusName: STATUS_NAMES[status] || `Unknown (${status})`,
                m_hdr,
                slotIdx: currentSlotIdx,
                slotsToUse: defaultSlotsToUse,
                startPos
            };

            // Process custom status for UNKNOWN (19)
            if (status === 19 && pos + 2 <= buffer.length) {
                const highByte = buffer[pos++];
                const lowByte = buffer[pos++];
                action.customStatus = (highByte << 2) | ((lowByte & 0xC0) >> 6);
            }

            // Process extended header if present
            if (m_hdr === 1 && pos < buffer.length) {
                const hdr = buffer[pos++];
                action.hdr = hdr;

                // Process slot index if present
                if ((hdr & SAM_LOG_HDR.SLOT_IDX) && pos + 3 <= buffer.length) {
                    action.slotIdx = (buffer[pos] << 16) | (buffer[pos + 1] << 8) | buffer[pos + 2];
                    pos += 3;
                }

                // Process slot difference if present
                if ((hdr & SAM_LOG_HDR.SLOT_IDX_DIFF) && pos + 2 <= buffer.length) {
                    let slotIdxDiff = (buffer[pos] << 8) | buffer[pos + 1];
                    if (slotIdxDiff & 0x8000) {
                        slotIdxDiff = -(0x10000 - slotIdxDiff);
                    }
                    action.slotIdxDiff = slotIdxDiff;
                    pos += 2;
                }

                // Process slots to use if present
                if ((hdr & SAM_LOG_HDR.SLOTS_TO_USE) && pos < buffer.length) {
                    action.slotsToUse = buffer[pos++];
                }

                // Process custom data
                if ((hdr & SAM_LOG_HDR.CUSTOM_FIELDS) && pos + 2 <= buffer.length) {
                    const customLen = (buffer[pos] << 8) | buffer[pos + 1];
                    action.customDataLength = customLen;
                    pos += 2;

                    // Extract custom data if available
                    if (customLen > 0 && pos + customLen <= buffer.length) {
                        action.customData = Array.from(buffer.slice(pos, pos + customLen))
                            .map(b => b.toString(16).padStart(2, '0'));
                        pos += customLen;
                    }
                }

                // Set scan flag if present
                if (hdr & SAM_LOG_HDR.SCAN) {
                    action.isScan = true;
                }

                // Flag if this sets default slots
                if (hdr & SAM_LOG_HDR.DEFAULT_SLOTS_TO_USE) {
                    action.setsDefaultSlots = true;
                }
            }

            return { action, newPos: pos };
        }

        // Parse SAM log data
        function parseLogData(buffer, logName) {
            const actions = [];
            let defaultSlotsToUse = 1;
            let currentSlotIdx = 0;
            let pos = 0;

            if (!buffer || buffer.length === 0) {
                return { actions, debugInfo: ["Empty buffer"] };
            }

            // Process all valid actions in the buffer
            while (pos < buffer.length) {
                // Check if this looks like a valid action header
                if (!isValidActionHeader(buffer, pos)) {
                    break;
                }

                // Determine total action length (header + custom data)
                const actionLength = getActionTotalLength(buffer, pos);

                // Safety check - make sure we don't overrun the buffer
                if (pos + actionLength > buffer.length) {
                    break;
                }

                // Parse this action
                const { action, newPos } = parseAction(buffer, pos, defaultSlotsToUse, currentSlotIdx);

                // Validate the parsed action
                if (action.slotIdx > 1000000 || action.slotsToUse > 100) {
                    break;
                }

                // Add the action
                actions.push(action);

                // Update tracking for next action
                if (action.status === 14) { // SYNCH_DONE
                    currentSlotIdx = action.slotIdx;
                } else {
                    currentSlotIdx = action.slotIdx + action.slotsToUse;
                }

                // Update default slots if specified
                if (action.setsDefaultSlots) {
                    defaultSlotsToUse = action.slotsToUse;
                }

                // Move to next action
                pos = newPos;

                // Safety check for infinite loops
                if (actions.length > 1000) {
                    break;
                }
            }

            return { actions };
        }

        // Parse SAM log lines
        function parseLog(logText) {
            const logs = [];
            // Match log patterns including Zephyr log timestamp and level format
            const logPattern = /(?:\[\d{2}:\d{2}:\d{2}\.\d{3},\d{3}\]\s+<\w+>\s+)?sam_log:\s+LOG\[(.*?)\]\s+(START|END)\s+(\d+)\s+(.*)/;
            const lines = logText.split('\n');

            // For long logs that span multiple lines
            let longLogName = '';
            let longLogBuffer = '';
            let longLogBufferName = '';
            let longLogEpochId = 0;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === '') continue;

                const match = line.match(logPattern);
                if (match) {
                    const [_, logName, bufferName, epochId, encodedData] = match;

                    // Check if this is a long log that spans multiple lines
                    if (i + 1 < lines.length && !lines[i + 1].match(logPattern) && lines[i + 1].trim() !== '') {
                        // This is the start of a multi-line log
                        longLogName = logName;
                        longLogBufferName = bufferName;
                        longLogEpochId = parseInt(epochId);
                        longLogBuffer = encodedData;

                        // Continue appending lines until we find another LOG pattern or end of input
                        let j = i + 1;
                        while (j < lines.length && !lines[j].match(logPattern) && lines[j].trim() !== '') {
                            longLogBuffer += lines[j].trim();
                            j++;
                        }

                        // Skip the lines we just processed
                        i = j - 1;

                        // Process the complete log
                        try {
                            const decodedData = decodeZ85(longLogBuffer);

                            if (decodedData && decodedData.length > 0) {
                                const { actions } = parseLogData(decodedData, longLogName);
                                logs.push({
                                    logName: longLogName,
                                    bufferName: longLogBufferName,
                                    epochId: longLogEpochId,
                                    actions,
                                    decodedData
                                });
                            }
                        } catch (e) {
                            console.error("Error processing multi-line log:", e);
                        }
                    } else {
                        // Regular single-line log
                        try {
                            const decodedData = decodeZ85(encodedData);
                            if (decodedData && decodedData.length > 0) {
                                const { actions } = parseLogData(decodedData, logName);
                                logs.push({
                                    logName,
                                    bufferName,
                                    epochId: parseInt(epochId),
                                    actions,
                                    decodedData
                                });
                            }
                        } catch (e) {
                            console.error("Error parsing log:", e);
                        }
                    }
                }
            }

            return logs;
        }

        // Format header bits for display
        function formatHeaderBits(hdr) {
            if (hdr === undefined) return '';

            const bits = [];
            if (hdr & SAM_LOG_HDR.SLOT_IDX) bits.push('SLOT_IDX');
            if (hdr & SAM_LOG_HDR.SLOTS_TO_USE) bits.push('SLOTS_TO_USE');
            if (hdr & SAM_LOG_HDR.SLOT_IDX_DIFF) bits.push('SLOT_IDX_DIFF');
            if (hdr & SAM_LOG_HDR.SCAN) bits.push('SCAN');
            if (hdr & SAM_LOG_HDR.CUSTOM_FIELDS) bits.push('CUSTOM_FIELDS');
            if (hdr & SAM_LOG_HDR.DEFAULT_SLOTS_TO_USE) bits.push('DEFAULT_SLOTS_TO_USE');

            return bits.join(', ');
        }

        // Display parsed results
        function displayResults(logs) {
            const resultDiv = document.getElementById('detailed-results');
            const summaryDiv = document.getElementById('summary-section');

            if (logs.length === 0) {
                resultDiv.innerHTML = '<p>No valid logs found.</p>';
                summaryDiv.innerHTML = '';
                return;
            }

            // Build summary section
            let summaryHtml = '<h2>Log Summary</h2>';
            logs.forEach((log, index) => {
                summaryHtml += `
                    <div class="summary-log" onclick="document.getElementById('log-section-${index}').scrollIntoView({behavior: 'smooth'})">
                        ${log.logName} - ${log.bufferName} (Epoch ${log.epochId}): ${log.actions.length} actions
                    </div>
                `;
            });
            summaryDiv.innerHTML = summaryHtml;

            // Build detailed results
            let html = '';

            // Display results for each log
            logs.forEach((log, logIndex) => {
                html += `
                    <div id="log-section-${logIndex}" class="log-section">
                        <h2>Log: ${log.logName}, Section: ${log.bufferName}, Epoch: ${log.epochId}</h2>
                        <p><strong>Found ${log.actions.length} actions</strong></p>
                `;

                // Show hex dump
                if (log.decodedData && log.decodedData.length > 0) {
                    html += `
                        <details>
                            <summary>Hex Dump</summary>
                            <pre>${hexDump(log.decodedData)}</pre>
                        </details>
                    `;
                }

                // Table of actions
                if (log.actions.length > 0) {
                    html += `
                        <table>
                            <thead>
                                <tr>
                                    <th>#</th>
                                    <th>Status</th>
                                    <th>Slot Index</th>
                                    <th>Slots To Use</th>
                                    <th>Slot Diff</th>
                                    <th>Custom Data</th>
                                </tr>
                            </thead>
                            <tbody>
                    `;

                    // Add rows for each action
                    log.actions.forEach((action, index) => {
                        const rowClass = getStatusClass(action.status);

                        html += `
                            <tr class="${rowClass}">
                                <td>${index + 1}</td>
                                <td>${action.statusName} (${action.status})</td>
                                <td>${action.slotIdx !== undefined ? action.slotIdx : '-'}</td>
                                <td>${action.slotsToUse !== undefined ? action.slotsToUse : '1'}</td>
                                <td>${action.slotIdxDiff !== undefined ? action.slotIdxDiff : '-'}</td>
                                <td class="custom-data">${action.customData ? action.customData.join(' ') : 'None'}</td>
                            </tr>
                        `;
                    });

                    html += `
                            </tbody>
                        </table>
                    `;
                } else {
                    html += `<p>No valid actions found in this log.</p>`;
                }

                html += `</div>`;
            });

            resultDiv.innerHTML = html;
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function () {
            const parseButton = document.getElementById('parse-button');
            const inputArea = document.getElementById('input');

            // Parse button handler
            parseButton.addEventListener('click', function () {
                const logs = parseLog(inputArea.value);
                displayResults(logs);
            });
        });
    </script>
</body>

</html>