<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SAM Log Analyzer</title>
    <style>
        body {
            font-family: system-ui, sans-serif;
            margin: 20px;
            line-height: 1.5;
        }

        h1,
        h2,
        h3 {
            color: #2a4d69;
        }

        textarea {
            width: 100%;
            height: 150px;
            margin: 10px 0;
            padding: 8px;
            font-family: monospace;
        }

        button {
            padding: 8px 16px;
            margin-right: 8px;
            margin-bottom: 10px;
        }

        .result {
            border: 1px solid #ccc;
            padding: 15px;
            margin-top: 20px;
            border-radius: 4px;
        }

        .summary-log {
            margin: 5px 0;
            padding: 8px;
            background-color: #f8f9fa;
            border-left: 4px solid #2a4d69;
            cursor: pointer;
        }

        .summary-log:hover {
            background-color: #e9ecef;
        }

        .log-section {
            margin-bottom: 30px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 20px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th,
        td {
            text-align: left;
            padding: 8px;
            border-bottom: 1px solid #ddd;
        }

        th {
            background-color: #f2f2f2;
        }

        .custom-data {
            font-family: monospace;
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .custom-data:hover {
            white-space: normal;
            overflow: visible;
        }

        pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            overflow: auto;
            font-family: monospace;
        }

        .binary-view {
            font-family: monospace;
            line-height: 1.3;
        }

        .binary-byte {
            color: #0066cc;
            margin-right: 5px;
        }

        .binary-byte-divider {
            color: #999;
            margin: 0 2px;
        }

        .error {
            color: #d9534f;
            font-weight: bold;
        }

        .debug {
            color: #5bc0de;
            font-style: italic;
        }

        .options-group {
            margin: 10px 0;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
        }

        .options-group label {
            margin-right: 20px;
        }
    </style>
</head>

<body>
    <h1>SAM Log Analyzer</h1>

    <div>
        <button id="load-clipboard">Load from Clipboard</button>
        <button id="load-basic">Load Basic Log</button>
        <button id="load-custom">Load Custom Data Log</button>
        <button id="load-epoch">Load Epoch Simulation Log</button>
        <button id="load-overflow">Load Overflow Log</button>
    </div>

    <textarea id="input" placeholder="Paste SAM log here..."></textarea>

    <div class="options-group">
        <label><input type="checkbox" id="show-hex-dump" checked> Show Hex Dump of Decoded Data</label>
        <label><input type="checkbox" id="show-binary-view" checked> Show Binary View of Decoded Data</label>
        <label><input type="checkbox" id="show-debug" checked> Show Debug Info</label>
    </div>

    <div class="result" id="result">
        <div id="summary-section"></div>
        <div id="detailed-results"></div>
    </div>

    <script>
        // Z85 decoder with robust error handling
        function decodeZ85(encoded) {
            if (!encoded || encoded.length === 0) return new Uint8Array(0);

            // Clean up the encoded string - remove any whitespace, newlines
            encoded = encoded.replace(/\s+/g, "");

            // Known valid Z85 chars
            const base85 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-:+=^!/*?&<>()[]{}@%$#";
            const lookup = {};
            for (let i = 0; i < base85.length; i++) {
                lookup[base85[i]] = i;
            }

            // Check if string has valid length (multiple of 5 chars plus possible padding)
            const paddingDigit = parseInt(encoded.charAt(0));
            let encodedData = encoded;
            let padding = 0;

            if (!isNaN(paddingDigit) && paddingDigit >= 1 && paddingDigit <= 4) {
                // Valid padding digit
                encodedData = encoded.substring(1);
                padding = 4 - paddingDigit;
            }

            // Handle invalid length - just use what we can
            if (encodedData.length % 5 !== 0) {
                const extra = encodedData.length % 5;
                // Take groups of 5 characters only
                encodedData = encodedData.substring(0, encodedData.length - extra);
            }

            if (encodedData.length === 0) {
                return new Uint8Array(0);
            }

            // Calculate output length and create buffer
            const decodedLength = Math.floor(encodedData.length * 4 / 5);
            const result = new Uint8Array(decodedLength);

            // Decode each 5-character group into 4 bytes
            let j = 0;
            for (let i = 0; i < encodedData.length; i += 5) {
                if (i + 4 >= encodedData.length) break;

                // Check for valid characters before decoding
                const chars = [
                    encodedData[i],
                    encodedData[i + 1],
                    encodedData[i + 2],
                    encodedData[i + 3],
                    encodedData[i + 4]
                ];

                if (chars.some(char => lookup[char] === undefined)) {
                    // Skip this group if any character is invalid
                    continue;
                }

                // Decode 5 characters into value
                let value = 0;
                for (let k = 0; k < 5; k++) {
                    value = value * 85 + lookup[encodedData[i + k]];
                }

                // Write 4 bytes, big endian
                if (j + 3 < result.length) {
                    result[j] = (value >> 24) & 0xFF;
                    result[j + 1] = (value >> 16) & 0xFF;
                    result[j + 2] = (value >> 8) & 0xFF;
                    result[j + 3] = value & 0xFF;
                    j += 4;
                }
            }

            // Adjust for padding if needed
            if (!isNaN(paddingDigit) && paddingDigit < 4) {
                return result.slice(0, decodedLength - padding);
            }

            return result;
        }

        // Create hex dump of binary data
        function hexDump(data) {
            const hexChars = '0123456789ABCDEF';
            let hexOutput = '';
            let asciiOutput = '';
            let output = '';

            for (let i = 0; i < data.length; i++) {
                // Start a new line every 16 bytes
                if (i % 16 === 0) {
                    if (i > 0) {
                        output += hexOutput + ' | ' + asciiOutput + '\n';
                        hexOutput = '';
                        asciiOutput = '';
                    }
                    hexOutput = (i).toString(16).padStart(4, '0') + ': ';
                }

                // Add hex representation
                const byte = data[i];
                hexOutput += hexChars[(byte >> 4) & 0xF] + hexChars[byte & 0xF] + ' ';

                // Add ASCII representation
                asciiOutput += (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
            }

            // Add the last line if there's anything left
            if (hexOutput) {
                // Pad the last line to align the ASCII output
                while (hexOutput.length < 49) {
                    hexOutput += '   ';
                }
                output += hexOutput + ' | ' + asciiOutput;
            }

            return output;
        }

        // Create binary view of data
        function binaryView(data) {
            let output = '';

            for (let i = 0; i < data.length; i++) {
                // Start a new line every 8 bytes
                if (i % 8 === 0) {
                    if (i > 0) {
                        output += '\n';
                    }
                    output += (i).toString(16).padStart(4, '0') + ': ';
                }

                // Convert byte to binary representation
                const byte = data[i];
                const binary = byte.toString(2).padStart(8, '0');

                // Format binary with highlighting and nibble separator
                const formattedBinary = `<span class="binary-byte">${binary.slice(0, 4)}<span class="binary-byte-divider">_</span>${binary.slice(4)}</span>`;

                output += formattedBinary + ' ';
            }

            return output;
        }

        // Strict validation of action headers
        function isValidActionHeader(buffer, pos) {
            if (pos >= buffer.length) return false;

            // First byte: check m_hdr and status
            const firstByte = buffer[pos];
            const m_hdr = (firstByte & 0x80) >> 7;
            const status = firstByte & 0x1F;

            // Status must be in range 0-19, and reserved bits must be 0
            if (status > 19 || (firstByte & 0x60) !== 0) return false;

            // If m_hdr is set, we need enough bytes for header
            if (m_hdr === 1) {
                if (pos + 1 >= buffer.length) return false;

                // Check header byte - must be a reasonable value
                const hdr = buffer[pos + 1];
                if (hdr > 63) return false; // Header should have reasonable bit pattern
            }

            return true;
        }

        // Get the total length of an action (header + custom data)
        function getActionTotalLength(buffer, pos) {
            const SAM_LOG_HDR = {
                SLOT_IDX: (1 << 0),
                SLOTS_TO_USE: (1 << 1),
                SLOT_IDX_DIFF: (1 << 2),
                SCAN: (1 << 3),
                CUSTOM_FIELDS: (1 << 4),
                DEFAULT_SLOTS_TO_USE: (1 << 5)
            };

            const firstByte = buffer[pos];
            const m_hdr = (firstByte & 0x80) >> 7;
            const status = firstByte & 0x1F;

            // If no m_hdr, just the status byte
            if (m_hdr === 0) return 1;

            // Header byte is at position pos+1
            if (pos + 1 >= buffer.length) return 1;

            const hdr = buffer[pos + 1];

            // Start with the base size (m_hdr + header byte)
            let size = 2;

            // Check for custom status bytes if status is SAM_LOG_UNKNOWN (19)
            if (status === 19) {
                size += 2; // 10-bit custom status
            }

            // Add size for other fields based on header bits
            if (hdr & SAM_LOG_HDR.SLOT_IDX) size += 3;
            if (hdr & SAM_LOG_HDR.SLOT_IDX_DIFF) size += 2;
            if (hdr & SAM_LOG_HDR.SLOTS_TO_USE) size += 1;

            // Add size for custom data length field if present
            if (hdr & SAM_LOG_HDR.CUSTOM_FIELDS) {
                size += 2;

                // If within bounds, add the actual custom data length
                if (pos + size <= buffer.length) {
                    const customLen = (buffer[pos + size - 2] << 8) | buffer[pos + size - 1];
                    size += customLen;
                }
            }

            return size;
        }

        // Correctly parse a single action, returning action object and new position
        function parseAction(buffer, pos, defaultSlotsToUse, currentSlotIdx) {
            const SAM_LOG_HDR = {
                SLOT_IDX: (1 << 0),
                SLOTS_TO_USE: (1 << 1),
                SLOT_IDX_DIFF: (1 << 2),
                SCAN: (1 << 3),
                CUSTOM_FIELDS: (1 << 4),
                DEFAULT_SLOTS_TO_USE: (1 << 5)
            };

            const STATUS_NAMES = {
                0: 'RX_SUCCESS', 1: 'RX_TIMEOUT', 2: 'RX_ERROR', 3: 'RX_MALFORMED',
                4: 'RX_LISTEN_LATE', 5: 'RX_LISTEN_FAIL', 6: 'TIMER_EVENT', 7: 'TX_DONE',
                8: 'TX_SCHED_LATE', 9: 'TX_SCHED_FAIL', 14: 'SYNCH_DONE',
                15: 'SYNCH_FAIL', 16: 'SKIP_SUCCESS', 17: 'RESTART_LATE', 18: 'RESTART_FAIL',
                19: 'UNKNOWN'
            };

            const startPos = pos;

            // First byte: m_hdr and status
            const firstByte = buffer[pos++];
            const m_hdr = (firstByte & 0x80) >> 7;
            const status = firstByte & 0x1F;

            // Create action object
            const action = {
                status,
                statusName: STATUS_NAMES[status] || `Unknown (${status})`,
                m_hdr,
                slotIdx: currentSlotIdx,
                slotsToUse: defaultSlotsToUse,
                startPos
            };

            // Process custom status for UNKNOWN (SAM_LOG_UNKNOWN = 19)
            if (status === 19 && pos + 2 <= buffer.length) {
                // Read the custom status (10 bits)
                const highByte = buffer[pos++];
                const lowByte = buffer[pos++];

                // Extract 10-bit value (8 from highByte, 2 from top of lowByte)
                action.customStatus = (highByte << 2) | ((lowByte & 0xC0) >> 6);
            }

            // Process extended header if present
            if (m_hdr === 1 && pos < buffer.length) {
                const hdr = buffer[pos++];
                action.hdr = hdr;

                // Process slot index if present
                if ((hdr & SAM_LOG_HDR.SLOT_IDX) && pos + 3 <= buffer.length) {
                    action.slotIdx = (buffer[pos] << 16) | (buffer[pos + 1] << 8) | buffer[pos + 2];
                    pos += 3;
                }

                // Process slot difference if present
                if ((hdr & SAM_LOG_HDR.SLOT_IDX_DIFF) && pos + 2 <= buffer.length) {
                    let slotIdxDiff = (buffer[pos] << 8) | buffer[pos + 1];
                    if (slotIdxDiff & 0x8000) {
                        slotIdxDiff = -(0x10000 - slotIdxDiff);
                    }
                    action.slotIdxDiff = slotIdxDiff;
                    pos += 2;
                }

                // Process slots to use if present
                if ((hdr & SAM_LOG_HDR.SLOTS_TO_USE) && pos < buffer.length) {
                    action.slotsToUse = buffer[pos++];
                }

                // Process custom data
                if ((hdr & SAM_LOG_HDR.CUSTOM_FIELDS) && pos + 2 <= buffer.length) {
                    const customLen = (buffer[pos] << 8) | buffer[pos + 1];
                    action.customDataLength = customLen;
                    pos += 2;

                    // Extract custom data if available
                    if (customLen > 0 && pos + customLen <= buffer.length) {
                        action.customData = Array.from(buffer.slice(pos, pos + customLen))
                            .map(b => b.toString(16).padStart(2, '0'));
                        pos += customLen;
                    }
                }

                // Set scan flag if present
                if (hdr & SAM_LOG_HDR.SCAN) {
                    action.isScan = true;
                }

                // Flag if this sets default slots
                if (hdr & SAM_LOG_HDR.DEFAULT_SLOTS_TO_USE) {
                    action.setsDefaultSlots = true;
                }
            }

            return { action, newPos: pos };
        }

        // Parse SAM log data with clean handling of boundaries
        function parseLogData(buffer, logName) {
            const actions = [];
            let defaultSlotsToUse = 1;
            let currentSlotIdx = 0;
            let pos = 0;
            let debugInfo = [];

            // Sanity check on buffer
            if (!buffer || buffer.length === 0) {
                debugInfo.push("Empty buffer");
                return { actions, debugInfo };
            }

            debugInfo.push(`Decoding buffer of ${buffer.length} bytes`);

            // Process all valid actions in the buffer
            while (pos < buffer.length) {
                // Check if this looks like a valid action header
                if (!isValidActionHeader(buffer, pos)) {
                    debugInfo.push(`Stopping at pos 0x${pos.toString(16).toUpperCase()}: Not a valid action header`);
                    break;
                }

                // Determine total action length (header + custom data)
                const actionLength = getActionTotalLength(buffer, pos);

                // Safety check - make sure we don't overrun the buffer
                if (pos + actionLength > buffer.length) {
                    debugInfo.push(`Action at pos 0x${pos.toString(16).toUpperCase()} would exceed buffer bounds (length 0x${actionLength.toString(16).toUpperCase()})`);
                    break;
                }

                // Parse this action
                const { action, newPos } = parseAction(buffer, pos, defaultSlotsToUse, currentSlotIdx);

                // Validate the parsed action
                if (action.slotIdx > 1000000 || action.slotsToUse > 100) {
                    debugInfo.push(`Suspicious action at pos 0x${pos.toString(16).toUpperCase()}: slot_idx=${action.slotIdx}, slots_to_use=${action.slotsToUse}`);
                    break;
                }

                // Add the action
                actions.push(action);

                // Update tracking for next action
                if (action.status === 14) { // SYNCH_DONE
                    currentSlotIdx = action.slotIdx;
                } else {
                    currentSlotIdx = action.slotIdx + action.slotsToUse;
                }

                // Update default slots if specified
                if (action.setsDefaultSlots) {
                    defaultSlotsToUse = action.slotsToUse;
                    debugInfo.push(`Updated default slots to ${defaultSlotsToUse} at action ${actions.length} (pos 0x${pos.toString(16).toUpperCase()})`);
                }

                // Move to next action
                pos = newPos;

                // Safety check for infinite loops
                if (actions.length > 1000) {
                    debugInfo.push(`Too many actions, stopping parse at pos 0x${pos.toString(16).toUpperCase()}`);
                    break;
                }
            }

            // Add summary information
            if (actions.length > 0) {
                const customDataCount = actions.filter(a => a.customData).length;
                const lastPos = pos.toString(16).toUpperCase();
                debugInfo.push(`Found ${actions.length} valid actions, ${customDataCount} with custom data (parsed to pos 0x${lastPos})`);
            }

            return {
                actions,
                debugInfo
            };
        }

        // Parse SAM log lines
        function parseLog(logText) {
            const logs = [];
            const logPattern = /LOG\[(.*?)\] (START|END) (\d+) (.*)/;
            const lines = logText.split('\n');

            // For long logs, we need to handle them specially
            let longLogName = '';
            let longLogBuffer = '';
            let longLogBufferName = '';
            let longLogEpochId = 0;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === '') continue;

                const match = line.match(logPattern);
                if (match) {
                    const [_, logName, bufferName, epochId, encodedData] = match;

                    // Check if this is a long log that spans multiple lines
                    if (i + 1 < lines.length && !lines[i + 1].match(logPattern) && lines[i + 1].trim() !== '') {
                        // This is the start of a multi-line log
                        longLogName = logName;
                        longLogBufferName = bufferName;
                        longLogEpochId = parseInt(epochId);
                        longLogBuffer = encodedData;

                        // Continue appending lines until we find another LOG pattern or end of input
                        let j = i + 1;
                        while (j < lines.length && !lines[j].match(logPattern) && lines[j].trim() !== '') {
                            longLogBuffer += lines[j].trim();
                            j++;
                        }

                        // Skip the lines we just processed
                        i = j - 1;

                        // Process the complete log
                        try {
                            const decodedData = decodeZ85(longLogBuffer);

                            if (decodedData && decodedData.length > 0) {
                                const { actions, debugInfo } = parseLogData(decodedData, longLogName);

                                logs.push({
                                    logName: longLogName,
                                    bufferName: longLogBufferName,
                                    epochId: longLogEpochId,
                                    actions,
                                    debugInfo: [`Multi-line log (${longLogBuffer.length} bytes encoded)`, ...debugInfo],
                                    decodedData
                                });
                            } else {
                                logs.push({
                                    logName: longLogName,
                                    bufferName: longLogBufferName,
                                    epochId: longLogEpochId,
                                    actions: [],
                                    debugInfo: [`Failed to decode multi-line Z85 data (${longLogBuffer.length} bytes)`],
                                    decodedData: new Uint8Array(0)
                                });
                            }
                        } catch (e) {
                            console.error("Error processing multi-line log:", e);
                            logs.push({
                                logName: longLogName,
                                bufferName: longLogBufferName,
                                epochId: longLogEpochId,
                                actions: [],
                                debugInfo: [`Error processing multi-line log: ${e.message}`],
                                decodedData: new Uint8Array(0)
                            });
                        }
                    } else {
                        // Regular single-line log
                        try {
                            const decodedData = decodeZ85(encodedData);

                            if (decodedData && decodedData.length > 0) {
                                const { actions, debugInfo } = parseLogData(decodedData, logName);

                                logs.push({
                                    logName,
                                    bufferName,
                                    epochId: parseInt(epochId),
                                    actions,
                                    debugInfo,
                                    decodedData
                                });
                            } else {
                                logs.push({
                                    logName,
                                    bufferName,
                                    epochId: parseInt(epochId),
                                    actions: [],
                                    debugInfo: ["Failed to decode Z85 data"],
                                    decodedData: new Uint8Array(0)
                                });
                            }
                        } catch (e) {
                            console.error("Error parsing log:", e);
                            logs.push({
                                logName,
                                bufferName,
                                epochId: parseInt(epochId),
                                actions: [],
                                debugInfo: [`Error parsing log: ${e.message}`],
                                decodedData: new Uint8Array(0)
                            });
                        }
                    }
                }
            }

            return logs;
        }

        // Format header bits for display
        function formatHeaderBits(hdr) {
            if (hdr === undefined) return '';

            const SAM_LOG_HDR = {
                SLOT_IDX: (1 << 0),
                SLOTS_TO_USE: (1 << 1),
                SLOT_IDX_DIFF: (1 << 2),
                SCAN: (1 << 3),
                CUSTOM_FIELDS: (1 << 4),
                DEFAULT_SLOTS_TO_USE: (1 << 5)
            };

            const bits = [];
            if (hdr & SAM_LOG_HDR.SLOT_IDX) bits.push('SLOT_IDX');
            if (hdr & SAM_LOG_HDR.SLOTS_TO_USE) bits.push('SLOTS_TO_USE');
            if (hdr & SAM_LOG_HDR.SLOT_IDX_DIFF) bits.push('SLOT_IDX_DIFF');
            if (hdr & SAM_LOG_HDR.SCAN) bits.push('SCAN');
            if (hdr & SAM_LOG_HDR.CUSTOM_FIELDS) bits.push('CUSTOM_FIELDS');
            if (hdr & SAM_LOG_HDR.DEFAULT_SLOTS_TO_USE) bits.push('DEFAULT_SLOTS_TO_USE');

            return bits.join(', ');
        }

        // Display parsed results
        function displayResults(logs) {
            const resultDiv = document.getElementById('detailed-results');
            const summaryDiv = document.getElementById('summary-section');
            const showHexDump = document.getElementById('show-hex-dump').checked;
            const showBinaryView = document.getElementById('show-binary-view').checked;
            const showDebug = document.getElementById('show-debug').checked;

            if (logs.length === 0) {
                resultDiv.innerHTML = '<p>No valid logs found.</p>';
                summaryDiv.innerHTML = '';
                return;
            }

            // Build summary section
            let summaryHtml = '<h2>Log Summary</h2>';
            logs.forEach((log, index) => {
                summaryHtml += `
                    <div class="summary-log" onclick="document.getElementById('log-section-${index}').scrollIntoView({behavior: 'smooth'})">
                        ${log.logName} - ${log.bufferName} (Epoch ${log.epochId}): ${log.actions.length} actions
                    </div>
                `;
            });
            summaryDiv.innerHTML = summaryHtml;

            // Build detailed results
            let html = '';

            // Display results for each log
            logs.forEach((log, logIndex) => {
                html += `
                    <div id="log-section-${logIndex}" class="log-section">
                        <h2>Log: ${log.logName}, Section: ${log.bufferName}, Epoch: ${log.epochId}</h2>
                        <p><strong>Found ${log.actions.length} actions</strong></p>
                `;

                // Show debug info if enabled
                if (showDebug && log.debugInfo && log.debugInfo.length > 0) {
                    html += `
                        <details>
                            <summary>Debug Information</summary>
                            <div class="debug">
                                <ul>
                                    ${log.debugInfo.map(info => `<li>${info}</li>`).join('')}
                                </ul>
                            </div>
                        </details>
                    `;
                }

                // Show hex dump if enabled
                if (showHexDump && log.decodedData && log.decodedData.length > 0) {
                    html += `
                        <details>
                            <summary>Hex Dump of Decoded Data</summary>
                            <pre>${hexDump(log.decodedData)}</pre>
                        </details>
                    `;
                }

                // Show binary view if enabled
                if (showBinaryView && log.decodedData && log.decodedData.length > 0) {
                    html += `
                        <details>
                            <summary>Binary View of Decoded Data</summary>
                            <div class="binary-view">
                                <pre>${binaryView(log.decodedData)}</pre>
                            </div>
                        </details>
                    `;
                }

                if (log.actions.length === 0) {
                    html += `<p class="error">No valid actions found in this log.</p>`;
                } else {
                    // Table of actions
                    html += `
                        <table>
                            <thead>
                                <tr>
                                    <th>#</th>
                                    <th>Status</th>
                                    <th>Custom Status</th>
                                    <th>Header Bits</th>
                                    <th>Slot Index</th>
                                    <th>Slots To Use</th>
                                    <th>Sets Default</th>
                                    <th>Slot Diff</th>
                                    <th>Custom Data</th>
                                </tr>
                            </thead>
                            <tbody>
                    `;

                    // Add rows for each action
                    log.actions.forEach((action, index) => {
                        html += `
                            <tr>
                                <td>${index + 1}</td>
                                <td>${action.statusName} (${action.status})</td>
                                <td>${action.customStatus !== undefined ? action.customStatus : '-'}</td>
                                <td>${formatHeaderBits(action.hdr)}</td>
                                <td>${action.slotIdx !== undefined ? action.slotIdx : '-'}</td>
                                <td>${action.slotsToUse !== undefined ? action.slotsToUse : '1'}</td>
                                <td>${action.setsDefaultSlots ? 'Yes' : 'No'}</td>
                                <td>${action.slotIdxDiff !== undefined ? action.slotIdxDiff : '-'}</td>
                                <td class="custom-data">${action.customData ? action.customData.join(' ') : 'None'}</td>
                            </tr>
                        `;
                    });

                    html += `
                            </tbody>
                        </table>
                    `;
                }

                html += `</div>`;
            });

            resultDiv.innerHTML = html;
        }

        // Set up event listeners
        document.addEventListener('DOMContentLoaded', function () {
            const inputArea = document.getElementById('input');

            // Add input change event handler
            inputArea.addEventListener('input', function () {
                const logs = parseLog(inputArea.value);
                displayResults(logs);
            });

            document.getElementById('load-basic').addEventListener('click', function () {
                inputArea.value = '[00:00:00.000,000] <inf> sam_log: LOG[BASIC] START 1 10eyNP04JH5001+O0SSi2';
                // Trigger parsing immediately
                inputArea.dispatchEvent(new Event('input'));
            });

            document.getElementById('load-custom').addEventListener('click', function () {
                inputArea.value = '[00:00:00.110,000] <inf> sam_log: LOG[CUSTOM] START 2 3FdR+Ywb)ev0rJua1Qkhq2)}4G4gS]76952z0STty0rJua1Qkhq2)}4G4gS)W5Ft->6=4P585:Cl9uDp5';
                inputArea.dispatchEvent(new Event('input'));
            });

            document.getElementById('load-epoch').addEventListener('click', function () {
                inputArea.value = '[00:00:00.220,000] <inf> sam_log: LOG[EPOCH] START 3 1GAh5P>ZTlB1l/^*?MsJXHA=^3(h($F00z=)KokE+]92eJ2lj(700igZ0@@D40rr916=4P585:Cl9uDp5';
                inputArea.dispatchEvent(new Event('input'));
            });

            document.getElementById('load-overflow').addEventListener('click', function () {
                inputArea.value = '[00:00:00.330,000] <inf> sam_log: LOG[OVERFLOW] START 4 3Hz6T)=&BaHS>lHh2l$Fs00--l2zS@)2IGgU1GG8T?3je&2lj#l2m31$00?M=00Gsl+?SHe2l$kl2l$G?695p90rrn5YuG7o2l$Fl2l$FsHz6T){Ygu$S>lHh2l$Fs00--l2zS@)2M+2b1GG8T?3je&2lj#l2m31$00&#l00Gsl+?SHe2l$kl2l$G?695pN0rrn5YuG\n7o2l$Fl2l$FsHz6T[aoqDBS>lHh2l$Fs00--l2zS@)2R2&P1GG8T?3je&2lj#l2m31$00>yZ00Gsl+?SHe2l$kl2l$G?695q40rrn5YuG7o2l$Fl2l$FsHz6T[nc5X[S>lHh2l$Fs00--l2zS@)2VpW61GG8T?3je&2lj#l2m31$00(*g00Gsl+?SHe2l$kl2l$G?695qI0rrn5YuG7o2l$Fl2l$FsHz6T[z#/}wS>lHh2l$Fs00--l2zS@)2ZM\nHK1GG8T?3je&2lj#l2m31$00[kU00Gsl+?SHe2l$kl2l$G?695q#0rrn5YuG7o2l$Fl2l$FsHz6T[M&Nf&S>lHh2l$Fs00--l2zS@)2+?t11GG8T?3je&2lj#l2m31$00]Ub00Gsl+?SHe2l$kl2l$G?695rD0rrn5YuG7o2l$Fl2l$FsHz6T[ZYsArS>lHh2l$Fs00--l2zS@)2*9eF1GG8T?3je&2lj#e\n[00:00:00.330,000] <inf> sam_log: LOG[OVERFLOW] END 4 4Hz6T[}#D^2S>lHh2l$kl2l$G?695sy0rrn5YuG7o2l$Fl2l$FsHz6T]5ch+lS>lHh2l$Fs00--l2zS@)2]S*A1GG8T?3je&2lj#l2m31$00%[K00Gsl+?SHe2l$kl2l$G?695s>0rrn5YuG7o2l$Fl2l$FsHz6T]h#%0ZS>lHh2l$Fs00--l2zS@)2%[T)1GG8T?3je&\n2lj#l2m31$00#s100Gsl+?SHe2l$kl2l$G?695tt0rrn5YuG7o2l$Fl2l$FsHz6T]u&ZlgS>lHh2l$Fs00--l2zS@)32fFv1GG8T?3je&2lj#l2m31$010-F00Gsl+?SHe2l$kl2l$G?695t/0rrn5YuG7o2l$Fl2l$FsHz6T]HYEFUS>lHh2l$Fs00--l2zS@)36Cq?1GG8T?3je&2lj#l2m31$012d@00Gsl+?SHe2l$kl2l$G?695uo0rrn5\nYuG7o2l$Fl2l$FsHz6T]UMj.bS>lHh2l$Fs00--l2zS@)3aZcq1GG8T?3je&2lj#l2m31$013NA00Gsl+?SHe2l$kl2l$G?695u:0rrn5YuG7o2l$Fl2l$FsHz6T]/z$%PS>lHh2l$Fs00--l2zS@)3e$%=1GG8T?3je&2lj#l2m31$014#)00Gsl+?SHe2l$kl2l$G?695vj0rrn5YuG7o2l$Fl2l$FsHz6T{00965S>lHh2l$Fs00--l2zS@)\n3jl!l1GG8T?3je&2lj#l2m31$016zv00Gsl+?SHe2l$kl2l$G?695vX0rrn5YuG7o2l$Fl2l$Fs2l$Fs';
                inputArea.dispatchEvent(new Event('input'));
            });

            // Add event listener for checkbox changes
            document.querySelectorAll('.options-group input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', function () {
                    // Re-run display with current input
                    const logs = parseLog(inputArea.value);
                    displayResults(logs);
                });
            });

            // Add event listener for clipboard button
            document.getElementById('load-clipboard').addEventListener('click', async function () {
                try {
                    const text = await navigator.clipboard.readText();
                    inputArea.value = text;
                    inputArea.dispatchEvent(new Event('input'));
                } catch (err) {
                    alert('Could not read from clipboard. Please paste manually.\n\nError: ' + err.message);
                }
            });

            // Load the CUSTOM log by default
            document.getElementById('load-custom').click();
        });
    </script>
</body>

</html>